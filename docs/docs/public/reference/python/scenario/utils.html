<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.11.6" />
<title>scenario.utils API documentation</title>
<meta name="description" content="Utility functions for scenario execution and message handling â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸª½</text></svg>" data-rh="true">
</head>
<body>
<style>
.navbar.navbar--fixed-top{
background-color: #fff;
box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.1);
display: flex;
height: 3.75rem;
padding: 0.5rem 1rem;
}
.navbar__inner {
display: flex;
flex-wrap: wrap;
justify-content: space-between;
width: 100%;
}
.navbar__items {
align-items: center;
display: flex;
flex: 1;
min-width: 0;
}
.navbar__items--right {
flex: 0 0 auto;
justify-content: flex-end;
}
.navbar__link {
color: #1c1e21;
font-weight: 500;
}
.navbar__link:hover, .navbar__link--active {
color: #2e8555;
text-decoration: none;
}
.navbar__item {
display: inline-block;
padding: 0.25em 0.75em;
}
.navbar a {
text-decoration: none;
transition: color 200ms cubic-bezier(0.08, 0.52, 0.52, 1);
}
.navbar__brand {
align-items: center;
color: #1c1e21;
display: flex;
margin-right: 1rem;
min-width: 0;
}
.iconExternalLink_node_modules-\@docusaurus-theme-classic-lib-theme-Icon-ExternalLink-styles-module {
margin-left: 0.3rem;
}
</style>
<nav aria-label="Main" class="navbar navbar--fixed-top">
<div class="navbar__inner" style="display: flex;
flex-wrap: wrap;
justify-content: space-between;
width: 100%;">
<div class="navbar__items">
<a class="navbar__brand" href="/scenario/"
><b class="navbar__title text--truncate">Scenario</b></a
><a
aria-current="page"
class="navbar__item navbar__link"
href="/scenario/docs/intro"
>Docs</a
>
<a
aria-current="page"
class="navbar__item navbar__link navbar__link--active"
href="/scenario/reference/scenario/index.html"
>Reference</a
>
</div>
<div class="navbar__items navbar__items--right">
<a
href="https://github.com/langwatch/scenario"
target="_blank"
rel="noopener noreferrer"
class="navbar__item navbar__link"
style="display: flex; align-items: center"
>GitHub<svg
width="13.5"
height="13.5"
aria-hidden="true"
viewBox="0 0 24 24"
class="iconExternalLink_node_modules-@docusaurus-theme-classic-lib-theme-Icon-ExternalLink-styles-module"
>
<path
fill="currentColor"
d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"
></path></svg
></a>
</div>
</div>
<div role="presentation" class="navbar-sidebar__backdrop"></div>
</nav>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>scenario.utils</code></h1>
</header>
<section id="section-intro">
<p>Utility functions for scenario execution and message handling.</p>
<p>This module provides various utility functions used throughout the Scenario framework,
including message formatting, validation, role reversal, and UI components like spinners
for better user experience during scenario execution.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Utility functions for scenario execution and message handling.

This module provides various utility functions used throughout the Scenario framework,
including message formatting, validation, role reversal, and UI components like spinners
for better user experience during scenario execution.
&#34;&#34;&#34;

from contextlib import contextmanager
import sys
from typing import (
    Any,
    Iterator,
    List,
    Literal,
    Optional,
    Union,
    TypeVar,
    Awaitable,
    cast,
)
from pydantic import BaseModel
import copy

import json

import termcolor
from textwrap import indent
from openai.types.chat import ChatCompletionMessageParam
from rich.live import Live
from rich.spinner import Spinner
from rich.console import Console
from rich.text import Text
from rich.errors import LiveError

from scenario.error_messages import message_return_error_message
from scenario.types import AgentReturnTypes, ScenarioResult

T = TypeVar(&#34;T&#34;)


class SerializableAndPydanticEncoder(json.JSONEncoder):
    &#34;&#34;&#34;
    JSON encoder that handles Pydantic models and iterators.

    This encoder extends the standard JSON encoder to handle Pydantic BaseModel
    instances and iterator objects, converting them to serializable formats.
    Used for caching and logging scenarios that contain complex objects.

    Example:
        data = {
            &#34;model&#34;: SomeBaseModel(field=&#34;value&#34;),
            &#34;iterator&#34;: iter([1, 2, 3])
        }
        json.dumps(data, cls=SerializableAndPydanticEncoder)
    &#34;&#34;&#34;
    def default(self, o):
        if isinstance(o, BaseModel):
            return o.model_dump(exclude_unset=True)
        if isinstance(o, Iterator):
            return list(o)
        return super().default(o)


class SerializableWithStringFallback(SerializableAndPydanticEncoder):
    &#34;&#34;&#34;
    JSON encoder with string fallback for non-serializable objects.

    This encoder extends SerializableAndPydanticEncoder by providing a string
    fallback for any object that cannot be serialized normally. This ensures
    that logging and caching operations never fail due to serialization issues.

    Example:
        # This will work even with complex non-serializable objects
        data = {&#34;function&#34;: lambda x: x, &#34;complex_object&#34;: SomeComplexClass()}
        json.dumps(data, cls=SerializableWithStringFallback)
        # Result: {&#34;function&#34;: &#34;&lt;function &lt;lambda&gt; at 0x...&gt;&#34;, &#34;complex_object&#34;: &#34;...&#34;}
    &#34;&#34;&#34;
    def default(self, o):
        try:
            return super().default(o)
        except:
            return str(o)


def safe_list_at(list, index, default=None):
    &#34;&#34;&#34;
    Safely get an item from a list by index with a default fallback.

    Args:
        list: The list to access
        index: The index to retrieve
        default: Value to return if index is out of bounds

    Returns:
        The item at the index, or the default value if index is invalid

    Example:
        items = [&#34;a&#34;, &#34;b&#34;, &#34;c&#34;]
        print(safe_list_at(items, 1))    # &#34;b&#34;
        print(safe_list_at(items, 10))   # None
        print(safe_list_at(items, 10, &#34;default&#34;))  # &#34;default&#34;
    &#34;&#34;&#34;
    try:
        return list[index]
    except:
        return default


def safe_attr_or_key(obj, attr_or_key, default=None):
    &#34;&#34;&#34;
    Safely get an attribute or dictionary key from an object.

    Tries to get the value as an attribute first, then as a dictionary key,
    returning the default if neither exists.

    Args:
        obj: Object to access (can have attributes or be dict-like)
        attr_or_key: Name of attribute or key to retrieve
        default: Value to return if attribute/key doesn&#39;t exist

    Returns:
        The attribute/key value, or the default if not found

    Example:
        class MyClass:
            attr = &#34;value&#34;

        obj = MyClass()
        dict_obj = {&#34;key&#34;: &#34;value&#34;}

        print(safe_attr_or_key(obj, &#34;attr&#34;))     # &#34;value&#34;
        print(safe_attr_or_key(dict_obj, &#34;key&#34;)) # &#34;value&#34;
        print(safe_attr_or_key(obj, &#34;missing&#34;))  # None
    &#34;&#34;&#34;
    return getattr(obj, attr_or_key, obj.get(attr_or_key))


def title_case(string):
    &#34;&#34;&#34;
    Convert snake_case string to Title Case.

    Args:
        string: Snake_case string to convert

    Returns:
        String converted to Title Case

    Example:
        print(title_case(&#34;user_simulator_agent&#34;))  # &#34;User Simulator Agent&#34;
        print(title_case(&#34;api_key&#34;))               # &#34;Api Key&#34;
    &#34;&#34;&#34;
    return &#34; &#34;.join(word.capitalize() for word in string.split(&#34;_&#34;))


def print_openai_messages(
    scenario_name: str, messages: list[ChatCompletionMessageParam]
):
    &#34;&#34;&#34;
    Print OpenAI-format messages with colored formatting for readability.

    This function formats and prints conversation messages with appropriate
    colors and formatting for different message types (user, assistant, tool calls, etc.).
    Used for verbose output during scenario execution.

    Args:
        scenario_name: Name of the scenario (used as prefix)
        messages: List of OpenAI-compatible messages to print

    Example:
        messages = [
            {&#34;role&#34;: &#34;user&#34;, &#34;content&#34;: &#34;Hello&#34;},
            {&#34;role&#34;: &#34;assistant&#34;, &#34;content&#34;: &#34;Hi there!&#34;},
            {&#34;role&#34;: &#34;assistant&#34;, &#34;tool_calls&#34;: [{&#34;function&#34;: {&#34;name&#34;: &#34;search&#34;}}]}
        ]
        print_openai_messages(&#34;Test Scenario&#34;, messages)

    Note:
        - User messages are printed in green
        - Assistant messages are printed in blue
        - Tool calls are printed in magenta with formatted JSON
        - Long JSON content is truncated for readability
    &#34;&#34;&#34;
    for msg in messages:
        role = safe_attr_or_key(msg, &#34;role&#34;)
        content = safe_attr_or_key(msg, &#34;content&#34;)
        if role == &#34;assistant&#34;:
            tool_calls = safe_attr_or_key(msg, &#34;tool_calls&#34;)
            if content:
                print(scenario_name + termcolor.colored(&#34;Agent:&#34;, &#34;blue&#34;), content)
            if tool_calls:
                for tool_call in tool_calls:
                    function = safe_attr_or_key(tool_call, &#34;function&#34;)
                    name = safe_attr_or_key(function, &#34;name&#34;)
                    args = safe_attr_or_key(function, &#34;arguments&#34;, &#34;{}&#34;)
                    args = _take_maybe_json_first_lines(args)
                    print(
                        scenario_name
                        + termcolor.colored(f&#34;ToolCall({name}):&#34;, &#34;magenta&#34;),
                        f&#34;\n\n{indent(args, &#39; &#39; * 4)}\n&#34;,
                    )
        elif role == &#34;user&#34;:
            print(scenario_name + termcolor.colored(&#34;User:&#34;, &#34;green&#34;), content)
        elif role == &#34;tool&#34;:
            content = _take_maybe_json_first_lines(content or msg.__repr__())
            print(
                scenario_name + termcolor.colored(f&#34;ToolResult:&#34;, &#34;magenta&#34;),
                f&#34;\n\n{indent(content, &#39; &#39; * 4)}\n&#34;,
            )
        else:
            print(
                scenario_name + termcolor.colored(f&#34;{title_case(role)}:&#34;, &#34;magenta&#34;),
                msg.__repr__(),
            )


def _take_maybe_json_first_lines(string, max_lines=5):
    &#34;&#34;&#34;
    Truncate string content and format JSON if possible.

    Internal utility function that attempts to format content as JSON
    and truncates it to a reasonable number of lines for display.

    Args:
        string: Content to format and truncate
        max_lines: Maximum number of lines to show

    Returns:
        Formatted and potentially truncated string
    &#34;&#34;&#34;
    content = str(string)
    try:
        content = json.dumps(json.loads(content), indent=2)
    except:
        pass
    content = content.split(&#34;\n&#34;)
    if len(content) &gt; max_lines:
        content = content[:max_lines] + [&#34;...&#34;]
    return &#34;\n&#34;.join(content)


console = Console()


class TextFirstSpinner(Spinner):
    &#34;&#34;&#34;
    Custom spinner that displays text before the spinning animation.

    This class extends Rich&#39;s Spinner to show descriptive text followed
    by the spinning animation, improving the user experience during
    scenario execution by clearly indicating what operation is happening.

    Args:
        name: Name of the spinner animation style
        text: Descriptive text to show before the spinner
        color: Color for the descriptive text
        **kwargs: Additional arguments passed to the base Spinner class
    &#34;&#34;&#34;
    def __init__(self, name, text: str, color: str, **kwargs):
        super().__init__(
            name, &#34;&#34;, style=&#34;bold white&#34;, **kwargs
        )  # Initialize with empty text
        self.text_before = text
        self.color = color

    def render(self, time):
        # Get the original spinner frame
        spinner_frame = super().render(time)
        # Create a composite with text first, then spinner
        return Text(f&#34;{self.text_before} &#34;, style=self.color) + spinner_frame


@contextmanager
def show_spinner(
    text: str, color: str = &#34;white&#34;, enabled: Optional[Union[bool, int]] = None
):
    &#34;&#34;&#34;
    Context manager for displaying a spinner during long-running operations.

    Shows a spinning indicator with descriptive text while code executes
    within the context. Automatically cleans up the spinner display when
    the operation completes.

    Args:
        text: Descriptive text to show next to the spinner
        color: Color for the descriptive text
        enabled: Whether to show the spinner (respects verbose settings)

    Example:
        ```python
        with show_spinner(&#34;Calling agent...&#34;, color=&#34;blue&#34;, enabled=True):
            response = await agent.call(input_data)

        # Spinner automatically disappears when block completes
        print(&#34;Agent call completed&#34;)
        ```

    Note:
        - Spinner is automatically cleaned up when context exits
        - Gracefully handles multi-threading scenarios where multiple spinners might conflict
        - Cursor positioning ensures clean terminal output
    &#34;&#34;&#34;
    if not enabled:
        yield
    else:
        spinner = TextFirstSpinner(&#34;dots&#34;, text, color=color)
        try:
            with Live(spinner, console=console, refresh_per_second=20):
                yield
        # It happens when we are multi-threading, it&#39;s fine, just ignore it, you probably don&#39;t want multiple spinners at once anyway
        except LiveError:
            yield

        # Cursor up one line
        sys.stdout.write(&#34;\033[F&#34;)
        # Erase the line
        sys.stdout.write(&#34;\033[2K&#34;)


def check_valid_return_type(return_value: Any, class_name: str) -&gt; None:
    &#34;&#34;&#34;
    Validate that an agent&#39;s return value is in the expected format.

    This function ensures that agent adapters return values in one of the
    supported formats (string, OpenAI message, list of messages, or ScenarioResult).
    It also verifies that the returned data is JSON-serializable for caching.

    Args:
        return_value: The value returned by an agent&#39;s call method
        class_name: Name of the agent class (for error messages)

    Raises:
        ValueError: If the return value is not in a supported format

    Example:
        ```python
        # Valid return values
        check_valid_return_type(&#34;Hello world&#34;, &#34;MyAgent&#34;)  # OK
        check_valid_return_type({&#34;role&#34;: &#34;assistant&#34;, &#34;content&#34;: &#34;Hi&#34;}, &#34;MyAgent&#34;)  # OK
        check_valid_return_type([{&#34;role&#34;: &#34;assistant&#34;, &#34;content&#34;: &#34;Hi&#34;}], &#34;MyAgent&#34;)  # OK

        # Invalid return value
        check_valid_return_type(42, &#34;MyAgent&#34;)  # Raises ValueError
        ```
    &#34;&#34;&#34;
    def _is_valid_openai_message(message: Any) -&gt; bool:
        return (isinstance(message, dict) and &#34;role&#34; in message) or (
            isinstance(message, BaseModel) and hasattr(message, &#34;role&#34;)
        )

    if (
        isinstance(return_value, str)
        or _is_valid_openai_message(return_value)
        or (
            isinstance(return_value, list)
            and all(_is_valid_openai_message(message) for message in return_value)
        )
        or isinstance(return_value, ScenarioResult)
    ):
        try:
            json.dumps(return_value, cls=SerializableAndPydanticEncoder)
        except:
            raise ValueError(
                message_return_error_message(got=return_value, class_name=class_name)
            )

        return

    raise ValueError(
        message_return_error_message(got=return_value, class_name=class_name)
    )


def convert_agent_return_types_to_openai_messages(
    agent_response: AgentReturnTypes, role: Literal[&#34;user&#34;, &#34;assistant&#34;]
) -&gt; List[ChatCompletionMessageParam]:
    &#34;&#34;&#34;
    Convert various agent return types to standardized OpenAI message format.

    This function normalizes different return types from agent adapters into
    a consistent list of OpenAI-compatible messages that can be used throughout
    the scenario execution pipeline.

    Args:
        agent_response: Response from an agent adapter call
        role: The role to assign to string responses (&#34;user&#34; or &#34;assistant&#34;)

    Returns:
        List of OpenAI-compatible messages

    Raises:
        ValueError: If agent_response is a ScenarioResult (which should be handled separately)

    Example:
        ```python
        # String response
        messages = convert_agent_return_types_to_openai_messages(&#34;Hello&#34;, &#34;assistant&#34;)
        # Result: [{&#34;role&#34;: &#34;assistant&#34;, &#34;content&#34;: &#34;Hello&#34;}]

        # Dict response
        response = {&#34;role&#34;: &#34;assistant&#34;, &#34;content&#34;: &#34;Hi&#34;, &#34;tool_calls&#34;: [...]}
        messages = convert_agent_return_types_to_openai_messages(response, &#34;assistant&#34;)
        # Result: [{&#34;role&#34;: &#34;assistant&#34;, &#34;content&#34;: &#34;Hi&#34;, &#34;tool_calls&#34;: [...]}]

        # List response
        responses = [
            {&#34;role&#34;: &#34;assistant&#34;, &#34;content&#34;: &#34;Thinking...&#34;},
            {&#34;role&#34;: &#34;assistant&#34;, &#34;content&#34;: &#34;Here&#39;s the answer&#34;}
        ]
        messages = convert_agent_return_types_to_openai_messages(responses, &#34;assistant&#34;)
        # Result: Same list, validated and normalized
        ```
    &#34;&#34;&#34;
    if isinstance(agent_response, ScenarioResult):
        raise ValueError(
            &#34;Unexpectedly tried to convert a ScenarioResult to openai messages&#34;,
            agent_response.__repr__(),
        )

    def convert_maybe_object_to_openai_message(
        obj: Any,
    ) -&gt; ChatCompletionMessageParam:
        if isinstance(obj, dict):
            return cast(ChatCompletionMessageParam, obj)
        elif isinstance(obj, BaseModel):
            return cast(
                ChatCompletionMessageParam,
                obj.model_dump(
                    exclude_unset=True,
                    exclude_none=True,
                    exclude_defaults=True,
                    warnings=False,
                ),
            )
        else:
            raise ValueError(f&#34;Unexpected agent response type: {type(obj).__name__}&#34;)

    def ensure_dict(
        obj: T,
    ) -&gt; T:
        return json.loads(json.dumps(obj, cls=SerializableAndPydanticEncoder))

    if isinstance(agent_response, str):
        return [
            (
                {&#34;role&#34;: &#34;user&#34;, &#34;content&#34;: agent_response}
                if role == &#34;user&#34;
                else {&#34;role&#34;: &#34;assistant&#34;, &#34;content&#34;: agent_response}
            )
        ]
    elif isinstance(agent_response, list):
        return [
            ensure_dict(convert_maybe_object_to_openai_message(message))
            for message in agent_response
        ]
    else:
        return [ensure_dict(convert_maybe_object_to_openai_message(agent_response))]


def reverse_roles(
    messages: list[ChatCompletionMessageParam],
) -&gt; list[ChatCompletionMessageParam]:
    &#34;&#34;&#34;
    Reverses the roles of the messages in the list.

    Args:
        messages: The list of messages to reverse the roles of.
    &#34;&#34;&#34;

    reversed_messages = []
    for message in messages:
        message = copy.deepcopy(message)
        # Can&#39;t reverse tool calls
        if not safe_attr_or_key(message, &#34;content&#34;) or safe_attr_or_key(
            message, &#34;tool_calls&#34;
        ):
            # If no content nor tool calls, we should skip it entirely, as anthropic may generate some invalid ones e.g. pure {&#34;role&#34;: &#34;assistant&#34;}
            if safe_attr_or_key(message, &#34;tool_calls&#34;):
                reversed_messages.append(message)
            continue

        if type(message) == dict:
            if message[&#34;role&#34;] == &#34;user&#34;:
                message[&#34;role&#34;] = &#34;assistant&#34;
            elif message[&#34;role&#34;] == &#34;assistant&#34;:
                message[&#34;role&#34;] = &#34;user&#34;
        else:
            if getattr(message, &#34;role&#34;, None) == &#34;user&#34;:
                message.role = &#34;assistant&#34;  # type: ignore
            elif getattr(message, &#34;role&#34;, None) == &#34;assistant&#34;:
                message.role = &#34;user&#34;  # type: ignore

        reversed_messages.append(message)

    return reversed_messages


async def await_if_awaitable(value: T) -&gt; T:
    if isinstance(value, Awaitable):
        return await value
    else:
        return value</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="scenario.utils.await_if_awaitable"><code class="name flex">
<span>async def <span class="ident">await_if_awaitable</span></span>(<span>value:Â ~T) â€‘>Â ~T</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def await_if_awaitable(value: T) -&gt; T:
    if isinstance(value, Awaitable):
        return await value
    else:
        return value</code></pre>
</details>
</dd>
<dt id="scenario.utils.check_valid_return_type"><code class="name flex">
<span>def <span class="ident">check_valid_return_type</span></span>(<span>return_value:Â Any, class_name:Â str) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Validate that an agent's return value is in the expected format.</p>
<p>This function ensures that agent adapters return values in one of the
supported formats (string, OpenAI message, list of messages, or ScenarioResult).
It also verifies that the returned data is JSON-serializable for caching.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>return_value</code></strong></dt>
<dd>The value returned by an agent's call method</dd>
<dt><strong><code>class_name</code></strong></dt>
<dd>Name of the agent class (for error messages)</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the return value is not in a supported format</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python"># Valid return values
check_valid_return_type(&quot;Hello world&quot;, &quot;MyAgent&quot;)  # OK
check_valid_return_type({&quot;role&quot;: &quot;assistant&quot;, &quot;content&quot;: &quot;Hi&quot;}, &quot;MyAgent&quot;)  # OK
check_valid_return_type([{&quot;role&quot;: &quot;assistant&quot;, &quot;content&quot;: &quot;Hi&quot;}], &quot;MyAgent&quot;)  # OK

# Invalid return value
check_valid_return_type(42, &quot;MyAgent&quot;)  # Raises ValueError
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_valid_return_type(return_value: Any, class_name: str) -&gt; None:
    &#34;&#34;&#34;
    Validate that an agent&#39;s return value is in the expected format.

    This function ensures that agent adapters return values in one of the
    supported formats (string, OpenAI message, list of messages, or ScenarioResult).
    It also verifies that the returned data is JSON-serializable for caching.

    Args:
        return_value: The value returned by an agent&#39;s call method
        class_name: Name of the agent class (for error messages)

    Raises:
        ValueError: If the return value is not in a supported format

    Example:
        ```python
        # Valid return values
        check_valid_return_type(&#34;Hello world&#34;, &#34;MyAgent&#34;)  # OK
        check_valid_return_type({&#34;role&#34;: &#34;assistant&#34;, &#34;content&#34;: &#34;Hi&#34;}, &#34;MyAgent&#34;)  # OK
        check_valid_return_type([{&#34;role&#34;: &#34;assistant&#34;, &#34;content&#34;: &#34;Hi&#34;}], &#34;MyAgent&#34;)  # OK

        # Invalid return value
        check_valid_return_type(42, &#34;MyAgent&#34;)  # Raises ValueError
        ```
    &#34;&#34;&#34;
    def _is_valid_openai_message(message: Any) -&gt; bool:
        return (isinstance(message, dict) and &#34;role&#34; in message) or (
            isinstance(message, BaseModel) and hasattr(message, &#34;role&#34;)
        )

    if (
        isinstance(return_value, str)
        or _is_valid_openai_message(return_value)
        or (
            isinstance(return_value, list)
            and all(_is_valid_openai_message(message) for message in return_value)
        )
        or isinstance(return_value, ScenarioResult)
    ):
        try:
            json.dumps(return_value, cls=SerializableAndPydanticEncoder)
        except:
            raise ValueError(
                message_return_error_message(got=return_value, class_name=class_name)
            )

        return

    raise ValueError(
        message_return_error_message(got=return_value, class_name=class_name)
    )</code></pre>
</details>
</dd>
<dt id="scenario.utils.convert_agent_return_types_to_openai_messages"><code class="name flex">
<span>def <span class="ident">convert_agent_return_types_to_openai_messages</span></span>(<span>agent_response:Â strÂ |Â openai.types.chat.chat_completion_developer_message_param.ChatCompletionDeveloperMessageParamÂ |Â openai.types.chat.chat_completion_system_message_param.ChatCompletionSystemMessageParamÂ |Â openai.types.chat.chat_completion_user_message_param.ChatCompletionUserMessageParamÂ |Â openai.types.chat.chat_completion_assistant_message_param.ChatCompletionAssistantMessageParamÂ |Â openai.types.chat.chat_completion_tool_message_param.ChatCompletionToolMessageParamÂ |Â openai.types.chat.chat_completion_function_message_param.ChatCompletionFunctionMessageParamÂ |Â List[openai.types.chat.chat_completion_developer_message_param.ChatCompletionDeveloperMessageParamÂ |Â openai.types.chat.chat_completion_system_message_param.ChatCompletionSystemMessageParamÂ |Â openai.types.chat.chat_completion_user_message_param.ChatCompletionUserMessageParamÂ |Â openai.types.chat.chat_completion_assistant_message_param.ChatCompletionAssistantMessageParamÂ |Â openai.types.chat.chat_completion_tool_message_param.ChatCompletionToolMessageParamÂ |Â openai.types.chat.chat_completion_function_message_param.ChatCompletionFunctionMessageParam]Â |Â <a title="scenario.types.ScenarioResult" href="types.html#scenario.types.ScenarioResult">ScenarioResult</a>, role:Â Literal['user',Â 'assistant']) â€‘>Â List[openai.types.chat.chat_completion_developer_message_param.ChatCompletionDeveloperMessageParamÂ |Â openai.types.chat.chat_completion_system_message_param.ChatCompletionSystemMessageParamÂ |Â openai.types.chat.chat_completion_user_message_param.ChatCompletionUserMessageParamÂ |Â openai.types.chat.chat_completion_assistant_message_param.ChatCompletionAssistantMessageParamÂ |Â openai.types.chat.chat_completion_tool_message_param.ChatCompletionToolMessageParamÂ |Â openai.types.chat.chat_completion_function_message_param.ChatCompletionFunctionMessageParam]</span>
</code></dt>
<dd>
<div class="desc"><p>Convert various agent return types to standardized OpenAI message format.</p>
<p>This function normalizes different return types from agent adapters into
a consistent list of OpenAI-compatible messages that can be used throughout
the scenario execution pipeline.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>agent_response</code></strong></dt>
<dd>Response from an agent adapter call</dd>
<dt><strong><code>role</code></strong></dt>
<dd>The role to assign to string responses ("user" or "assistant")</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>List of OpenAI-compatible messages</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If agent_response is a ScenarioResult (which should be handled separately)</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python"># String response
messages = convert_agent_return_types_to_openai_messages(&quot;Hello&quot;, &quot;assistant&quot;)
# Result: [{&quot;role&quot;: &quot;assistant&quot;, &quot;content&quot;: &quot;Hello&quot;}]

# Dict response
response = {&quot;role&quot;: &quot;assistant&quot;, &quot;content&quot;: &quot;Hi&quot;, &quot;tool_calls&quot;: [...]}
messages = convert_agent_return_types_to_openai_messages(response, &quot;assistant&quot;)
# Result: [{&quot;role&quot;: &quot;assistant&quot;, &quot;content&quot;: &quot;Hi&quot;, &quot;tool_calls&quot;: [...]}]

# List response
responses = [
    {&quot;role&quot;: &quot;assistant&quot;, &quot;content&quot;: &quot;Thinking...&quot;},
    {&quot;role&quot;: &quot;assistant&quot;, &quot;content&quot;: &quot;Here's the answer&quot;}
]
messages = convert_agent_return_types_to_openai_messages(responses, &quot;assistant&quot;)
# Result: Same list, validated and normalized
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convert_agent_return_types_to_openai_messages(
    agent_response: AgentReturnTypes, role: Literal[&#34;user&#34;, &#34;assistant&#34;]
) -&gt; List[ChatCompletionMessageParam]:
    &#34;&#34;&#34;
    Convert various agent return types to standardized OpenAI message format.

    This function normalizes different return types from agent adapters into
    a consistent list of OpenAI-compatible messages that can be used throughout
    the scenario execution pipeline.

    Args:
        agent_response: Response from an agent adapter call
        role: The role to assign to string responses (&#34;user&#34; or &#34;assistant&#34;)

    Returns:
        List of OpenAI-compatible messages

    Raises:
        ValueError: If agent_response is a ScenarioResult (which should be handled separately)

    Example:
        ```python
        # String response
        messages = convert_agent_return_types_to_openai_messages(&#34;Hello&#34;, &#34;assistant&#34;)
        # Result: [{&#34;role&#34;: &#34;assistant&#34;, &#34;content&#34;: &#34;Hello&#34;}]

        # Dict response
        response = {&#34;role&#34;: &#34;assistant&#34;, &#34;content&#34;: &#34;Hi&#34;, &#34;tool_calls&#34;: [...]}
        messages = convert_agent_return_types_to_openai_messages(response, &#34;assistant&#34;)
        # Result: [{&#34;role&#34;: &#34;assistant&#34;, &#34;content&#34;: &#34;Hi&#34;, &#34;tool_calls&#34;: [...]}]

        # List response
        responses = [
            {&#34;role&#34;: &#34;assistant&#34;, &#34;content&#34;: &#34;Thinking...&#34;},
            {&#34;role&#34;: &#34;assistant&#34;, &#34;content&#34;: &#34;Here&#39;s the answer&#34;}
        ]
        messages = convert_agent_return_types_to_openai_messages(responses, &#34;assistant&#34;)
        # Result: Same list, validated and normalized
        ```
    &#34;&#34;&#34;
    if isinstance(agent_response, ScenarioResult):
        raise ValueError(
            &#34;Unexpectedly tried to convert a ScenarioResult to openai messages&#34;,
            agent_response.__repr__(),
        )

    def convert_maybe_object_to_openai_message(
        obj: Any,
    ) -&gt; ChatCompletionMessageParam:
        if isinstance(obj, dict):
            return cast(ChatCompletionMessageParam, obj)
        elif isinstance(obj, BaseModel):
            return cast(
                ChatCompletionMessageParam,
                obj.model_dump(
                    exclude_unset=True,
                    exclude_none=True,
                    exclude_defaults=True,
                    warnings=False,
                ),
            )
        else:
            raise ValueError(f&#34;Unexpected agent response type: {type(obj).__name__}&#34;)

    def ensure_dict(
        obj: T,
    ) -&gt; T:
        return json.loads(json.dumps(obj, cls=SerializableAndPydanticEncoder))

    if isinstance(agent_response, str):
        return [
            (
                {&#34;role&#34;: &#34;user&#34;, &#34;content&#34;: agent_response}
                if role == &#34;user&#34;
                else {&#34;role&#34;: &#34;assistant&#34;, &#34;content&#34;: agent_response}
            )
        ]
    elif isinstance(agent_response, list):
        return [
            ensure_dict(convert_maybe_object_to_openai_message(message))
            for message in agent_response
        ]
    else:
        return [ensure_dict(convert_maybe_object_to_openai_message(agent_response))]</code></pre>
</details>
</dd>
<dt id="scenario.utils.print_openai_messages"><code class="name flex">
<span>def <span class="ident">print_openai_messages</span></span>(<span>scenario_name:Â str, messages:Â list[openai.types.chat.chat_completion_developer_message_param.ChatCompletionDeveloperMessageParamÂ |Â openai.types.chat.chat_completion_system_message_param.ChatCompletionSystemMessageParamÂ |Â openai.types.chat.chat_completion_user_message_param.ChatCompletionUserMessageParamÂ |Â openai.types.chat.chat_completion_assistant_message_param.ChatCompletionAssistantMessageParamÂ |Â openai.types.chat.chat_completion_tool_message_param.ChatCompletionToolMessageParamÂ |Â openai.types.chat.chat_completion_function_message_param.ChatCompletionFunctionMessageParam])</span>
</code></dt>
<dd>
<div class="desc"><p>Print OpenAI-format messages with colored formatting for readability.</p>
<p>This function formats and prints conversation messages with appropriate
colors and formatting for different message types (user, assistant, tool calls, etc.).
Used for verbose output during scenario execution.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>scenario_name</code></strong></dt>
<dd>Name of the scenario (used as prefix)</dd>
<dt><strong><code>messages</code></strong></dt>
<dd>List of OpenAI-compatible messages to print</dd>
</dl>
<h2 id="example">Example</h2>
<p>messages = [
{"role": "user", "content": "Hello"},
{"role": "assistant", "content": "Hi there!"},
{"role": "assistant", "tool_calls": [{"function": {"name": "search"}}]}
]
print_openai_messages("Test Scenario", messages)</p>
<h2 id="note">Note</h2>
<ul>
<li>User messages are printed in green</li>
<li>Assistant messages are printed in blue</li>
<li>Tool calls are printed in magenta with formatted JSON</li>
<li>Long JSON content is truncated for readability</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_openai_messages(
    scenario_name: str, messages: list[ChatCompletionMessageParam]
):
    &#34;&#34;&#34;
    Print OpenAI-format messages with colored formatting for readability.

    This function formats and prints conversation messages with appropriate
    colors and formatting for different message types (user, assistant, tool calls, etc.).
    Used for verbose output during scenario execution.

    Args:
        scenario_name: Name of the scenario (used as prefix)
        messages: List of OpenAI-compatible messages to print

    Example:
        messages = [
            {&#34;role&#34;: &#34;user&#34;, &#34;content&#34;: &#34;Hello&#34;},
            {&#34;role&#34;: &#34;assistant&#34;, &#34;content&#34;: &#34;Hi there!&#34;},
            {&#34;role&#34;: &#34;assistant&#34;, &#34;tool_calls&#34;: [{&#34;function&#34;: {&#34;name&#34;: &#34;search&#34;}}]}
        ]
        print_openai_messages(&#34;Test Scenario&#34;, messages)

    Note:
        - User messages are printed in green
        - Assistant messages are printed in blue
        - Tool calls are printed in magenta with formatted JSON
        - Long JSON content is truncated for readability
    &#34;&#34;&#34;
    for msg in messages:
        role = safe_attr_or_key(msg, &#34;role&#34;)
        content = safe_attr_or_key(msg, &#34;content&#34;)
        if role == &#34;assistant&#34;:
            tool_calls = safe_attr_or_key(msg, &#34;tool_calls&#34;)
            if content:
                print(scenario_name + termcolor.colored(&#34;Agent:&#34;, &#34;blue&#34;), content)
            if tool_calls:
                for tool_call in tool_calls:
                    function = safe_attr_or_key(tool_call, &#34;function&#34;)
                    name = safe_attr_or_key(function, &#34;name&#34;)
                    args = safe_attr_or_key(function, &#34;arguments&#34;, &#34;{}&#34;)
                    args = _take_maybe_json_first_lines(args)
                    print(
                        scenario_name
                        + termcolor.colored(f&#34;ToolCall({name}):&#34;, &#34;magenta&#34;),
                        f&#34;\n\n{indent(args, &#39; &#39; * 4)}\n&#34;,
                    )
        elif role == &#34;user&#34;:
            print(scenario_name + termcolor.colored(&#34;User:&#34;, &#34;green&#34;), content)
        elif role == &#34;tool&#34;:
            content = _take_maybe_json_first_lines(content or msg.__repr__())
            print(
                scenario_name + termcolor.colored(f&#34;ToolResult:&#34;, &#34;magenta&#34;),
                f&#34;\n\n{indent(content, &#39; &#39; * 4)}\n&#34;,
            )
        else:
            print(
                scenario_name + termcolor.colored(f&#34;{title_case(role)}:&#34;, &#34;magenta&#34;),
                msg.__repr__(),
            )</code></pre>
</details>
</dd>
<dt id="scenario.utils.reverse_roles"><code class="name flex">
<span>def <span class="ident">reverse_roles</span></span>(<span>messages:Â list[openai.types.chat.chat_completion_developer_message_param.ChatCompletionDeveloperMessageParamÂ |Â openai.types.chat.chat_completion_system_message_param.ChatCompletionSystemMessageParamÂ |Â openai.types.chat.chat_completion_user_message_param.ChatCompletionUserMessageParamÂ |Â openai.types.chat.chat_completion_assistant_message_param.ChatCompletionAssistantMessageParamÂ |Â openai.types.chat.chat_completion_tool_message_param.ChatCompletionToolMessageParamÂ |Â openai.types.chat.chat_completion_function_message_param.ChatCompletionFunctionMessageParam]) â€‘>Â list[openai.types.chat.chat_completion_developer_message_param.ChatCompletionDeveloperMessageParamÂ |Â openai.types.chat.chat_completion_system_message_param.ChatCompletionSystemMessageParamÂ |Â openai.types.chat.chat_completion_user_message_param.ChatCompletionUserMessageParamÂ |Â openai.types.chat.chat_completion_assistant_message_param.ChatCompletionAssistantMessageParamÂ |Â openai.types.chat.chat_completion_tool_message_param.ChatCompletionToolMessageParamÂ |Â openai.types.chat.chat_completion_function_message_param.ChatCompletionFunctionMessageParam]</span>
</code></dt>
<dd>
<div class="desc"><p>Reverses the roles of the messages in the list.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>messages</code></strong></dt>
<dd>The list of messages to reverse the roles of.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reverse_roles(
    messages: list[ChatCompletionMessageParam],
) -&gt; list[ChatCompletionMessageParam]:
    &#34;&#34;&#34;
    Reverses the roles of the messages in the list.

    Args:
        messages: The list of messages to reverse the roles of.
    &#34;&#34;&#34;

    reversed_messages = []
    for message in messages:
        message = copy.deepcopy(message)
        # Can&#39;t reverse tool calls
        if not safe_attr_or_key(message, &#34;content&#34;) or safe_attr_or_key(
            message, &#34;tool_calls&#34;
        ):
            # If no content nor tool calls, we should skip it entirely, as anthropic may generate some invalid ones e.g. pure {&#34;role&#34;: &#34;assistant&#34;}
            if safe_attr_or_key(message, &#34;tool_calls&#34;):
                reversed_messages.append(message)
            continue

        if type(message) == dict:
            if message[&#34;role&#34;] == &#34;user&#34;:
                message[&#34;role&#34;] = &#34;assistant&#34;
            elif message[&#34;role&#34;] == &#34;assistant&#34;:
                message[&#34;role&#34;] = &#34;user&#34;
        else:
            if getattr(message, &#34;role&#34;, None) == &#34;user&#34;:
                message.role = &#34;assistant&#34;  # type: ignore
            elif getattr(message, &#34;role&#34;, None) == &#34;assistant&#34;:
                message.role = &#34;user&#34;  # type: ignore

        reversed_messages.append(message)

    return reversed_messages</code></pre>
</details>
</dd>
<dt id="scenario.utils.safe_attr_or_key"><code class="name flex">
<span>def <span class="ident">safe_attr_or_key</span></span>(<span>obj, attr_or_key, default=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Safely get an attribute or dictionary key from an object.</p>
<p>Tries to get the value as an attribute first, then as a dictionary key,
returning the default if neither exists.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>obj</code></strong></dt>
<dd>Object to access (can have attributes or be dict-like)</dd>
<dt><strong><code>attr_or_key</code></strong></dt>
<dd>Name of attribute or key to retrieve</dd>
<dt><strong><code>default</code></strong></dt>
<dd>Value to return if attribute/key doesn't exist</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The attribute/key value, or the default if not found</p>
<h2 id="example">Example</h2>
<p>class MyClass:
attr = "value"</p>
<p>obj = MyClass()
dict_obj = {"key": "value"}</p>
<p>print(safe_attr_or_key(obj, "attr"))
# "value"
print(safe_attr_or_key(dict_obj, "key")) # "value"
print(safe_attr_or_key(obj, "missing"))
# None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def safe_attr_or_key(obj, attr_or_key, default=None):
    &#34;&#34;&#34;
    Safely get an attribute or dictionary key from an object.

    Tries to get the value as an attribute first, then as a dictionary key,
    returning the default if neither exists.

    Args:
        obj: Object to access (can have attributes or be dict-like)
        attr_or_key: Name of attribute or key to retrieve
        default: Value to return if attribute/key doesn&#39;t exist

    Returns:
        The attribute/key value, or the default if not found

    Example:
        class MyClass:
            attr = &#34;value&#34;

        obj = MyClass()
        dict_obj = {&#34;key&#34;: &#34;value&#34;}

        print(safe_attr_or_key(obj, &#34;attr&#34;))     # &#34;value&#34;
        print(safe_attr_or_key(dict_obj, &#34;key&#34;)) # &#34;value&#34;
        print(safe_attr_or_key(obj, &#34;missing&#34;))  # None
    &#34;&#34;&#34;
    return getattr(obj, attr_or_key, obj.get(attr_or_key))</code></pre>
</details>
</dd>
<dt id="scenario.utils.safe_list_at"><code class="name flex">
<span>def <span class="ident">safe_list_at</span></span>(<span>list, index, default=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Safely get an item from a list by index with a default fallback.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>list</code></strong></dt>
<dd>The list to access</dd>
<dt><strong><code>index</code></strong></dt>
<dd>The index to retrieve</dd>
<dt><strong><code>default</code></strong></dt>
<dd>Value to return if index is out of bounds</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The item at the index, or the default value if index is invalid</p>
<h2 id="example">Example</h2>
<p>items = ["a", "b", "c"]
print(safe_list_at(items, 1))
# "b"
print(safe_list_at(items, 10))
# None
print(safe_list_at(items, 10, "default"))
# "default"</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def safe_list_at(list, index, default=None):
    &#34;&#34;&#34;
    Safely get an item from a list by index with a default fallback.

    Args:
        list: The list to access
        index: The index to retrieve
        default: Value to return if index is out of bounds

    Returns:
        The item at the index, or the default value if index is invalid

    Example:
        items = [&#34;a&#34;, &#34;b&#34;, &#34;c&#34;]
        print(safe_list_at(items, 1))    # &#34;b&#34;
        print(safe_list_at(items, 10))   # None
        print(safe_list_at(items, 10, &#34;default&#34;))  # &#34;default&#34;
    &#34;&#34;&#34;
    try:
        return list[index]
    except:
        return default</code></pre>
</details>
</dd>
<dt id="scenario.utils.show_spinner"><code class="name flex">
<span>def <span class="ident">show_spinner</span></span>(<span>text:Â str, color:Â strÂ =Â 'white', enabled:Â boolÂ |Â intÂ |Â NoneÂ =Â None)</span>
</code></dt>
<dd>
<div class="desc"><p>Context manager for displaying a spinner during long-running operations.</p>
<p>Shows a spinning indicator with descriptive text while code executes
within the context. Automatically cleans up the spinner display when
the operation completes.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>text</code></strong></dt>
<dd>Descriptive text to show next to the spinner</dd>
<dt><strong><code>color</code></strong></dt>
<dd>Color for the descriptive text</dd>
<dt><strong><code>enabled</code></strong></dt>
<dd>Whether to show the spinner (respects verbose settings)</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python">with show_spinner(&quot;Calling agent...&quot;, color=&quot;blue&quot;, enabled=True):
    response = await agent.call(input_data)

# Spinner automatically disappears when block completes
print(&quot;Agent call completed&quot;)
</code></pre>
<h2 id="note">Note</h2>
<ul>
<li>Spinner is automatically cleaned up when context exits</li>
<li>Gracefully handles multi-threading scenarios where multiple spinners might conflict</li>
<li>Cursor positioning ensures clean terminal output</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@contextmanager
def show_spinner(
    text: str, color: str = &#34;white&#34;, enabled: Optional[Union[bool, int]] = None
):
    &#34;&#34;&#34;
    Context manager for displaying a spinner during long-running operations.

    Shows a spinning indicator with descriptive text while code executes
    within the context. Automatically cleans up the spinner display when
    the operation completes.

    Args:
        text: Descriptive text to show next to the spinner
        color: Color for the descriptive text
        enabled: Whether to show the spinner (respects verbose settings)

    Example:
        ```python
        with show_spinner(&#34;Calling agent...&#34;, color=&#34;blue&#34;, enabled=True):
            response = await agent.call(input_data)

        # Spinner automatically disappears when block completes
        print(&#34;Agent call completed&#34;)
        ```

    Note:
        - Spinner is automatically cleaned up when context exits
        - Gracefully handles multi-threading scenarios where multiple spinners might conflict
        - Cursor positioning ensures clean terminal output
    &#34;&#34;&#34;
    if not enabled:
        yield
    else:
        spinner = TextFirstSpinner(&#34;dots&#34;, text, color=color)
        try:
            with Live(spinner, console=console, refresh_per_second=20):
                yield
        # It happens when we are multi-threading, it&#39;s fine, just ignore it, you probably don&#39;t want multiple spinners at once anyway
        except LiveError:
            yield

        # Cursor up one line
        sys.stdout.write(&#34;\033[F&#34;)
        # Erase the line
        sys.stdout.write(&#34;\033[2K&#34;)</code></pre>
</details>
</dd>
<dt id="scenario.utils.title_case"><code class="name flex">
<span>def <span class="ident">title_case</span></span>(<span>string)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert snake_case string to Title Case.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>string</code></strong></dt>
<dd>Snake_case string to convert</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>String converted to Title Case</p>
<h2 id="example">Example</h2>
<p>print(title_case("user_simulator_agent"))
# "User Simulator Agent"
print(title_case("api_key"))
# "Api Key"</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def title_case(string):
    &#34;&#34;&#34;
    Convert snake_case string to Title Case.

    Args:
        string: Snake_case string to convert

    Returns:
        String converted to Title Case

    Example:
        print(title_case(&#34;user_simulator_agent&#34;))  # &#34;User Simulator Agent&#34;
        print(title_case(&#34;api_key&#34;))               # &#34;Api Key&#34;
    &#34;&#34;&#34;
    return &#34; &#34;.join(word.capitalize() for word in string.split(&#34;_&#34;))</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="scenario.utils.SerializableAndPydanticEncoder"><code class="flex name class">
<span>class <span class="ident">SerializableAndPydanticEncoder</span></span>
<span>(</span><span>*, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, sort_keys=False, indent=None, separators=None, default=None)</span>
</code></dt>
<dd>
<div class="desc"><p>JSON encoder that handles Pydantic models and iterators.</p>
<p>This encoder extends the standard JSON encoder to handle Pydantic BaseModel
instances and iterator objects, converting them to serializable formats.
Used for caching and logging scenarios that contain complex objects.</p>
<h2 id="example">Example</h2>
<p>data = {
"model": SomeBaseModel(field="value"),
"iterator": iter([1, 2, 3])
}
json.dumps(data, cls=SerializableAndPydanticEncoder)</p>
<p>Constructor for JSONEncoder, with sensible defaults.</p>
<p>If skipkeys is false, then it is a TypeError to attempt
encoding of keys that are not str, int, float or None.
If
skipkeys is True, such items are simply skipped.</p>
<p>If ensure_ascii is true, the output is guaranteed to be str
objects with all incoming non-ASCII characters escaped.
If
ensure_ascii is false, the output can contain non-ASCII characters.</p>
<p>If check_circular is true, then lists, dicts, and custom encoded
objects will be checked for circular references during encoding to
prevent an infinite recursion (which would cause an RecursionError).
Otherwise, no such check takes place.</p>
<p>If allow_nan is true, then NaN, Infinity, and -Infinity will be
encoded as such.
This behavior is not JSON specification compliant,
but is consistent with most JavaScript based encoders and decoders.
Otherwise, it will be a ValueError to encode such floats.</p>
<p>If sort_keys is true, then the output of dictionaries will be
sorted by key; this is useful for regression tests to ensure
that JSON serializations can be compared on a day-to-day basis.</p>
<p>If indent is a non-negative integer, then JSON array
elements and object members will be pretty-printed with that
indent level.
An indent level of 0 will only insert newlines.
None is the most compact representation.</p>
<p>If specified, separators should be an (item_separator, key_separator)
tuple.
The default is (', ', ': ') if <em>indent</em> is <code>None</code> and
(',', ': ') otherwise.
To get the most compact JSON representation,
you should specify (',', ':') to eliminate whitespace.</p>
<p>If specified, default is a function that gets called for objects
that can't otherwise be serialized.
It should return a JSON encodable
version of the object or raise a <code>TypeError</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SerializableAndPydanticEncoder(json.JSONEncoder):
    &#34;&#34;&#34;
    JSON encoder that handles Pydantic models and iterators.

    This encoder extends the standard JSON encoder to handle Pydantic BaseModel
    instances and iterator objects, converting them to serializable formats.
    Used for caching and logging scenarios that contain complex objects.

    Example:
        data = {
            &#34;model&#34;: SomeBaseModel(field=&#34;value&#34;),
            &#34;iterator&#34;: iter([1, 2, 3])
        }
        json.dumps(data, cls=SerializableAndPydanticEncoder)
    &#34;&#34;&#34;
    def default(self, o):
        if isinstance(o, BaseModel):
            return o.model_dump(exclude_unset=True)
        if isinstance(o, Iterator):
            return list(o)
        return super().default(o)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>json.encoder.JSONEncoder</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="scenario.utils.SerializableWithStringFallback" href="#scenario.utils.SerializableWithStringFallback">SerializableWithStringFallback</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scenario.utils.SerializableAndPydanticEncoder.default"><code class="name flex">
<span>def <span class="ident">default</span></span>(<span>self, o)</span>
</code></dt>
<dd>
<div class="desc"><p>Implement this method in a subclass such that it returns
a serializable object for <code>o</code>, or calls the base implementation
(to raise a <code>TypeError</code>).</p>
<p>For example, to support arbitrary iterators, you could
implement default like this::</p>
<pre><code>def default(self, o):
    try:
        iterable = iter(o)
    except TypeError:
        pass
    else:
        return list(iterable)
    # Let the base class default method raise the TypeError
    return super().default(o)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def default(self, o):
    if isinstance(o, BaseModel):
        return o.model_dump(exclude_unset=True)
    if isinstance(o, Iterator):
        return list(o)
    return super().default(o)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scenario.utils.SerializableWithStringFallback"><code class="flex name class">
<span>class <span class="ident">SerializableWithStringFallback</span></span>
<span>(</span><span>*, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, sort_keys=False, indent=None, separators=None, default=None)</span>
</code></dt>
<dd>
<div class="desc"><p>JSON encoder with string fallback for non-serializable objects.</p>
<p>This encoder extends SerializableAndPydanticEncoder by providing a string
fallback for any object that cannot be serialized normally. This ensures
that logging and caching operations never fail due to serialization issues.</p>
<h2 id="example">Example</h2>
<h1 id="this-will-work-even-with-complex-non-serializable-objects">This will work even with complex non-serializable objects</h1>
<p>data = {"function": lambda x: x, "complex_object": SomeComplexClass()}
json.dumps(data, cls=SerializableWithStringFallback)</p>
<h1 _..._="&quot;...&quot;" _complex_object_:="&quot;complex_object&quot;:" _function_:="&quot;function&quot;:" _wzxhzdk:1_="&quot;<function \<lambda> at 0x...>&quot;," id="result">Result:</h1>
<p>Constructor for JSONEncoder, with sensible defaults.</p>
<p>If skipkeys is false, then it is a TypeError to attempt
encoding of keys that are not str, int, float or None.
If
skipkeys is True, such items are simply skipped.</p>
<p>If ensure_ascii is true, the output is guaranteed to be str
objects with all incoming non-ASCII characters escaped.
If
ensure_ascii is false, the output can contain non-ASCII characters.</p>
<p>If check_circular is true, then lists, dicts, and custom encoded
objects will be checked for circular references during encoding to
prevent an infinite recursion (which would cause an RecursionError).
Otherwise, no such check takes place.</p>
<p>If allow_nan is true, then NaN, Infinity, and -Infinity will be
encoded as such.
This behavior is not JSON specification compliant,
but is consistent with most JavaScript based encoders and decoders.
Otherwise, it will be a ValueError to encode such floats.</p>
<p>If sort_keys is true, then the output of dictionaries will be
sorted by key; this is useful for regression tests to ensure
that JSON serializations can be compared on a day-to-day basis.</p>
<p>If indent is a non-negative integer, then JSON array
elements and object members will be pretty-printed with that
indent level.
An indent level of 0 will only insert newlines.
None is the most compact representation.</p>
<p>If specified, separators should be an (item_separator, key_separator)
tuple.
The default is (', ', ': ') if <em>indent</em> is <code>None</code> and
(',', ': ') otherwise.
To get the most compact JSON representation,
you should specify (',', ':') to eliminate whitespace.</p>
<p>If specified, default is a function that gets called for objects
that can't otherwise be serialized.
It should return a JSON encodable
version of the object or raise a <code>TypeError</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SerializableWithStringFallback(SerializableAndPydanticEncoder):
    &#34;&#34;&#34;
    JSON encoder with string fallback for non-serializable objects.

    This encoder extends SerializableAndPydanticEncoder by providing a string
    fallback for any object that cannot be serialized normally. This ensures
    that logging and caching operations never fail due to serialization issues.

    Example:
        # This will work even with complex non-serializable objects
        data = {&#34;function&#34;: lambda x: x, &#34;complex_object&#34;: SomeComplexClass()}
        json.dumps(data, cls=SerializableWithStringFallback)
        # Result: {&#34;function&#34;: &#34;&lt;function &lt;lambda&gt; at 0x...&gt;&#34;, &#34;complex_object&#34;: &#34;...&#34;}
    &#34;&#34;&#34;
    def default(self, o):
        try:
            return super().default(o)
        except:
            return str(o)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scenario.utils.SerializableAndPydanticEncoder" href="#scenario.utils.SerializableAndPydanticEncoder">SerializableAndPydanticEncoder</a></li>
<li>json.encoder.JSONEncoder</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scenario.utils.SerializableAndPydanticEncoder" href="#scenario.utils.SerializableAndPydanticEncoder">SerializableAndPydanticEncoder</a></b></code>:
<ul class="hlist">
<li><code><a title="scenario.utils.SerializableAndPydanticEncoder.default" href="#scenario.utils.SerializableAndPydanticEncoder.default">default</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scenario.utils.TextFirstSpinner"><code class="flex name class">
<span>class <span class="ident">TextFirstSpinner</span></span>
<span>(</span><span>name, text:Â str, color:Â str, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Custom spinner that displays text before the spinning animation.</p>
<p>This class extends Rich's Spinner to show descriptive text followed
by the spinning animation, improving the user experience during
scenario execution by clearly indicating what operation is happening.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Name of the spinner animation style</dd>
<dt><strong><code>text</code></strong></dt>
<dd>Descriptive text to show before the spinner</dd>
<dt><strong><code>color</code></strong></dt>
<dd>Color for the descriptive text</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Additional arguments passed to the base Spinner class</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TextFirstSpinner(Spinner):
    &#34;&#34;&#34;
    Custom spinner that displays text before the spinning animation.

    This class extends Rich&#39;s Spinner to show descriptive text followed
    by the spinning animation, improving the user experience during
    scenario execution by clearly indicating what operation is happening.

    Args:
        name: Name of the spinner animation style
        text: Descriptive text to show before the spinner
        color: Color for the descriptive text
        **kwargs: Additional arguments passed to the base Spinner class
    &#34;&#34;&#34;
    def __init__(self, name, text: str, color: str, **kwargs):
        super().__init__(
            name, &#34;&#34;, style=&#34;bold white&#34;, **kwargs
        )  # Initialize with empty text
        self.text_before = text
        self.color = color

    def render(self, time):
        # Get the original spinner frame
        spinner_frame = super().render(time)
        # Create a composite with text first, then spinner
        return Text(f&#34;{self.text_before} &#34;, style=self.color) + spinner_frame</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>rich.spinner.Spinner</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scenario.utils.TextFirstSpinner.render"><code class="name flex">
<span>def <span class="ident">render</span></span>(<span>self, time)</span>
</code></dt>
<dd>
<div class="desc"><p>Render the spinner for a given time.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>time</code></strong> :&ensp;<code>float</code></dt>
<dd>Time in seconds.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>RenderableType</code></dt>
<dd>A renderable containing animation frame.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def render(self, time):
    # Get the original spinner frame
    spinner_frame = super().render(time)
    # Create a composite with text first, then spinner
    return Text(f&#34;{self.text_before} &#34;, style=self.color) + spinner_frame</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<a href="/" style="color: #000">â† Back to Docs</a>
<h1>Scenario API Reference</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="scenario" href="index.html">scenario</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="scenario.utils.await_if_awaitable" href="#scenario.utils.await_if_awaitable">await_if_awaitable</a></code></li>
<li><code><a title="scenario.utils.check_valid_return_type" href="#scenario.utils.check_valid_return_type">check_valid_return_type</a></code></li>
<li><code><a title="scenario.utils.convert_agent_return_types_to_openai_messages" href="#scenario.utils.convert_agent_return_types_to_openai_messages">convert_agent_return_types_to_openai_messages</a></code></li>
<li><code><a title="scenario.utils.print_openai_messages" href="#scenario.utils.print_openai_messages">print_openai_messages</a></code></li>
<li><code><a title="scenario.utils.reverse_roles" href="#scenario.utils.reverse_roles">reverse_roles</a></code></li>
<li><code><a title="scenario.utils.safe_attr_or_key" href="#scenario.utils.safe_attr_or_key">safe_attr_or_key</a></code></li>
<li><code><a title="scenario.utils.safe_list_at" href="#scenario.utils.safe_list_at">safe_list_at</a></code></li>
<li><code><a title="scenario.utils.show_spinner" href="#scenario.utils.show_spinner">show_spinner</a></code></li>
<li><code><a title="scenario.utils.title_case" href="#scenario.utils.title_case">title_case</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="scenario.utils.SerializableAndPydanticEncoder" href="#scenario.utils.SerializableAndPydanticEncoder">SerializableAndPydanticEncoder</a></code></h4>
<ul class="">
<li><code><a title="scenario.utils.SerializableAndPydanticEncoder.default" href="#scenario.utils.SerializableAndPydanticEncoder.default">default</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenario.utils.SerializableWithStringFallback" href="#scenario.utils.SerializableWithStringFallback">SerializableWithStringFallback</a></code></h4>
</li>
<li>
<h4><code><a title="scenario.utils.TextFirstSpinner" href="#scenario.utils.TextFirstSpinner">TextFirstSpinner</a></code></h4>
<ul class="">
<li><code><a title="scenario.utils.TextFirstSpinner.render" href="#scenario.utils.TextFirstSpinner.render">render</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
